---
layout: post
title: Is it time for the Java Bean Mapping revolution?
tags: Java BeanMapping DAMapping
---

When it comes to bean mapping, it is surprising to see how many tools/frameworks are available. Some as old and famous as [Dozer](http://dozer.sourceforge.net/), other more recent and innovative as [Selma](https://github.com/xebia-france/selma) (see this [highly referenced post](http://www.javacodegeeks.com/2013/10/java-object-to-object-mapper.html) if you need a list).

But no matter how different the technical underlying paradigms of these tools are, they have one thing in common: they take bean mapping code out of the application, either as XML or annotation configuration + reflection, or as generated bytecode or, more recently, as generated classes.

In my opinion and experience, this is a wrong approach to bean mapping and the cause of many problems in the life of an application.

Bean mapping can look like simple/boring/obvious/tedious-to-write code but it still holds a lot of business logic and as such must be plain part of the application code. We shouldn't take that code away or hide it.


# A little bit on my experience on the subject

I have worked for 3 years on a big online application for a major french telco as a senior developer and then as a technical lead.

This application integrates with nearly 100 web services (or other remote services), with a bunch business components, a database, throws DTOs to the client user interface expose as 150+ methods, ..., and internally, the application is obviously made of several software layers. Overall, bean mapping occurs in many places and is a strong aspect of the application.

Developers on this application tested several bean mapping solutions, from Dozer to fully hand coded mapping as the developer feels to write it, to extensive use of Guava's Function, to other exotic approaches. I saw them behave as time goes and as the application lives, and I learned a lot.

After three years, I must say that I didn't see any solution that ruled them all. I still have nightmare of the time I lost with some of them.

So, I started thinking about what bean mapping is really about, the problems I had and concluded that bean mapping should be very different.

# Existing tools were created to write mapping code

Bean mapping frameworks quick descriptions are all pretty much the same:

1. include our jar/declare maven dependency/some other kind of quick setup step
2. add this config file/this annotation/whatever to your application (optional)
3. with these 2/3/4 lines of code, Tadah ! class A is transformed into class B

Ok, good. This is simple enough and it solves the initial problem of the developer : writing the mapping code from one bean to another.

Bonus, it seems to also work for tree of beans and offers customisation possibilities.

Then, why should I be unhappy with this solution ?

Because writing the bean mapping code is far from the only concern of the developer, ence of the software architect : maintainability, stability, readability, support for debugging, learning curve for new developers, etc...

# The practical problems of hidden mapping code

As I said earlier, these frameworks remove the mapping code from the application and this introduces many practical problems as the application lives, grows (hopefully) and as developers come and go.

### bean mapping code is not source code in your application

Therefore it is not in SCM, you can not tell when nor where a change occurred and who did it. You can't tell either when some mapping code was added or if it actually was added.

### bean mapping code is not stable

The generated code/bytecode can change when upgrading the mapping framework and reflection-based mapping is even worse on that point.

Sure, you are supposed to have unit tests to ensure stability but, supposing unit tests break, you will waste time to fix pieces of code which had no reason to change in the first place since they were working.

### you can't leverage the power of your IDE

To find out where and how class `X` is instanced or property `foo` is set/read, you are on your own.

But when it is time to find out where a problem is coming from, believe me, you will curse the guy who decided to use a bean mapping tool instead of just writing dumb `b.setToto(a.getToto())` lines.

### debugging is usually not easy

Hidden mapping code is acting as a black box: when mapping a single bean to another, it is ok, when mapping tree of beans however, it is *not*.

Also, forget about putting a breakpoint in generated byte code or reflection-based frameworks code...

### no direct access to the mapping code for new developers

When a new developer joins the project, supposing she has to fix a bug or develop an evolution, she will need to learn some tool to know even about know about some dumb 1-to-1 mapping, where it happens and how.

### need to customise ? say goodbye to compiler feedback

When the time comes to customise the mapping, you generally lose compile-time feedback and type safety because you end up using strings to designate properties and/or are required to add some XML configuration and/or need to write some obscure implementation of a framework specific interface.

You can then forget about refactoring your bean classes and having the mapping code updated consistently by your IDE. Also forget about the compiler telling you that by changing the type of this property, your bean mapping code now fails to execute.

Some tool such as [ModelMapper](http://modelmapper.org/) provide a solution to this problem, but at the cost of very complexe and verbose technical solutions. It is way simpler to just write the bean mapping code from the beginning. In addition, everyone will understand it just by looking at it.

### immutability is not a prime citizen

Designing immutable bean wherever possible is a big constraint but it solves many issue in the long run.

Unfortunately, immutable bean are not well supported by bean mapping framework, notably because:

* it involves bean not having setters (basic requirement of property based framework)
    - immutable beans only have constructors to initialize their state or, better, builders
    - both constructors and builders can hardly be automatically mapped
* also mapping tree of immutable bean requires to map beans bottom-up instead of the usual top-bottom way
    - children of immutable bean must be created before their parent

### you can't investigate how mapping actually occurs

This applies especially to reflection-based or bytecode generation-based mapping. When you want to make sure the problem is not at the mapping level, good luck.

### you can't tell dead code apart

With most tools, it can be hard to tell that mapping configuration and/or customisation is actually dead code:

- is that line of configuration still required for mapping to occur ?
- is that custom whatever objet still used ?

Unless you have extensive test coverage and remove the suspicious part, sometime, you just can not tell.

### not much (or none) control over mapping of bean trees

When it comes to mapping trees of bean, you either do not have control over it or need to customize the framework and now code is not that simple any more:

- want to write one mapper for each node of a tree of beans, so you can really _unit_ test ? good luck
- want to keep type dependency between mappers so you can easily tell how your code behaves ? for some framework, that's just impossible

### performance ...

Performance is a big issue with reflection based mapping tools, they are very slow and CPU/memory intensive compared to plain Java code. In addition, this kind of code can never benefit from compiler and/or JVM optimisations.

Frameworks based on other technical paradigms always compare each other on that subject but no matter what I don't think they can beat plain Java code (unless you just write shitty Java code but that's not a bean mapping issue).

### etc.

(add here any other complain you have, I know I didn't write them all)

## The down side of bean mapping code in source

Naturally, every aspect stated above are no problem when bean mapping code is part of the application.

But I am also aware of the main reasons to hide bean mapping code:

* bean mapping code does not have much added value, no need to have it in the application
    - as I explain below, I think this statement is wrong
* if bean mapping code is not written in source, it can automatically adapt to change
    - true, but I think that using the IDE refactoring capabilities is a better way to adapt to change
    - in addition, I don't like losing control over my business code and as I presented above, this has many inconveniences
* but what about change that add properties for example?
    - I think the developer should explicitly write how the new property should be mapped, exactly as the developer should write the unit test for that mapping
    - and there again, every IDE is now capable of completion that make adding a setter call is just not a problem

Overall, I think there is more benefits (especially in the long run) than disadvantages in having bean mapping code in the application.

# Bean mapping code is business code

After thorough thinking, I found that the most important problem with bean mapping code being out of the application is that it removes business code from the application.

Yes, bean mapping code *is* business code.

Even exact 1-to-1 mapping is business logic. This code could have been different. Some properties could have been nullified or harcoded to a specific value on purpose. The fact it is not the case should be written in code. It **will** save any question in the future.

Also, the very facts that so many bugs occur at the bean mapping level and that such big parts of documentation are about mapping are the proof that bean mapping is business logic.

Bean mapping code is not some technical problem that a framework can hide/remove from the application.

But I agree, writing bean mapping *is* a technical problem.

# Bean Mapping is dead, long live Bean Mapping

Starting from the hypothesis that Bean Mapping code should be part of the application code as any other piece of business code, two questions arise:

1. Shouldn't that code be organised a bit ? If everyone starts writing bean mapping code without any guideline of some kind, code will just end up being a mess and it will be worse than before
2. Some mapping code is just no value to write and is a waste of time to type, shouldn't there be some tool to help the developer ?

And one strong constraint:

* the developer must always keep control over the code and the tool must stay out of the way

The answer to both questions is "obviously, yes!" and the constraint drove my research from a solution.

I think that what we need is not one tool, but two, very much complementary:

1. a framework to structure bean mapping code and handle the wiring with the rest of the application and with other pieces of bean mapping code
    + lets call it a Bean Mapping Wiring Framework
2. a tool/plugin at the IDE level to generates mapping code from one class to another
    + lets call it a Bean Mapping Code Generator

Those two tools would solve very different problems and could be used together or not. In addition, they would never be mandatory once you start using them, they would step out of the way anytime. This way the developer keep controls over the code.

Still, the ultimate goal is that these tools would be so convenient that they will end up in the coding guidelines of the team.

## Bean Mapping Wiring Framework

The Bean Mapping Wiring Framework is about letting the developer write the bean mapping code in a class and giving her the power to use that class's code as easily as possible:

* using interfaces for loose coupling
    - developer writes the implementation, the interface which will be used in other classes to call this implementation will be generated by the framework
* complying with Separation Of Concern
    - using a class for each mapping from one class to another
    - side effect, unit testing is much easier
* integrating with Dependency Injection framework
    - for example, generating Spring XML configuration files for the generated interfaces and the implementation
* providing coding patterns to help mapping complex structures of beans or solve common bean mapping problems
    - using Guava's Function to easily convert collections of beans or integrating with Java 8 lambas
    - using mapper factories when creating a bean from more than one source bean
    - etc.

To my knowledge, there is no such framework at the moment except [DAMapping](https://github.com/lesaint/damapping) which is at an early stage of developement.

## Bean Mapping Code Generator

The primary goal of this tool is to provide convenient generation of bean mapping code _inside_ the application's source code from one class to another. The IDE is the best place for this as we could rely on interactive UI to generate the source code living option to the developers.

Second goal of this tool is the integration with the Bean Mapping Wiring Framework. This integration would give the option to the developer to not only generate bean mapping code but also generate bean mapping classes. This would be a convenient way of creating the code for tree of beans without being intrusive about it.

Since the logic of generating mapping code already exists, developing this tool would really be a matter of IDE integration and UI design.

Generating the initial bean mapping code is relatively easy but this tool will obviously need to complete partial mapping code to be successful. And that's a little harder to do.

# Conclusion

People keep on creating new bean mapping tools, changing the technical approach but basically keeping the same paradigm which in my opinion is the root cause of their unhappiness with the solution they had before: hidden bean mapping code.

This post is clearly just a declaration of faith for now. I don't have any concrete solution to provide yet.

But this is a way of sharing my opinion on bean mapping and getting feedback. I know many people (very) unhappy with Dozer and such frameworks, I'm interesting in their opinion in my proposal of a better solution, maybe there contribution.

There is no comment in my blog, but you can contact me on [Twitter](https://twitter.com/LesaintSeb).

More post will follow on the details of the Bean Mapping Wiring Framework and the Bean Mapping Code Generator.
