---
layout: damapping
title: DAMapping framework 0.5.0
excerpt: Documentation of the DAMapping framework current version
css: damapping
categories:
 - damapping
comments: true
---

This page provides the documentation of the current version (0.5.0) of the DAMapping framework.

To get started using the framework, understand its purpose and usage, please look at the [getting started with the DAMapping framework]({{ site.url }}/damapping/framework/getting-started.html) page first.

* Table of Contents
{:toc}

Dedicated class
===============

A Class that holds a piece of object mapping code and is managed by the DAmapping framework is called a *dedicated class*.

## how to write one

There is very little constraints on how to write a *dedicated class*:

1. must be annotated with the `@Mapper` annotation provided by the framework
2. must be public or package protected
3. must define a single non-private method
    - it implies that it can not have any "getter" or "setter", use the constructor to get dependencies
    - rule will soon be restricted to a single public method
4. must either define a single non-private constructor or no constructor at all

Content of the *dedicated class* is totally free, the DAMapping framework cares only of its "interface".

## singleton enum

Enums as dedicated classes are supported by the DAMapping framework.

The only constraint is that they must define a single value (which name does not matter).

Using enums with a single value is the most recommended way to implement a Singleton in Java.

The developer may find it relevant to use a singleton for a dedicated class.

{% highlight java %}
@Mapper
public enum EnumBasedFooToBar {
  THE_ONE;

  @Override
  public Bar apply(@Nullable Foo foo) {
    // [...]
  }
}
{% endhighlight %}

## usage

The DAMapping framework assumes ownership of dedicated classes, therefor they are not really intended to be used directly except for unit tests.

This implies that the DAMapping framework will assume the responsibility of creating instances of the *dedicated class*.

## naming

Types will be generated by the framework which will be named by appending `Mapper` or `MapperImpl` to the name of the *dedicated class*, it is best to name the *dedicated class* with that in mind.

E.g. a *dedicated class* implementing the mapping from an object of type `Foo` to an object of type `Bar` could be named `FooToBar` to get nicely named types `FooToBarMapper` and `FooToBarMapperImpl`.

Mapper interface
================

The DAMapping framework generates the interface that could have been implemented by the *dedicated class* to achieve loose coupling. This generated interface is known as the *Mapper interface*.

## name and location

The name of the generated *Mapper interface* is created by appending `Mapper` to the name of the *dedicated class*: e.g. the *Mapper interface* for the *dedicated class* `FooToBar` will be named `FooToBarMapper`.

The *Mapper interface* is generated in the same package as the *dedicated class*.

## annotations

The generated *Mapper interface* does not have any annotation except the `@Generated` annotation which indicates that it is a generated type.

>The `@Generated` annotation is also used by DAMapping to resolve references to generated types in dedicated classes, see [Using Mapper interfaces in dedicated class](#using-mapper-interfaces-in-dedicated-class)

## interfaces: support for Guava's Function

The generated *Mapper interface* does not extend any interface with a specific exception: if the *dedicated class* implements Guava's Function interface, the *Mapper interface* will too.

>Support for Guava's Function is currently implemented in the core of the DAMapping framework but may latter be taken out into an extension.

## method

If the *dedicated class* implements Guava's Function interface, the *Mapper interface* will define no method.

Otherwise, it defines a single method (multiple method support is a planed feature) which has the same signature (including annotations on return type and parameters) of the "single non private method" defined by the *dedicated class*.

>change in the definition of the *Mapper interface*'s method is planned for [0.6.0](https://github.com/lesaint/damapping/milestones/0.6.0), it will then be the "single public method" of the *dedicated class*

If the *dedicated class* defines more than one non-private method, a compilation error will be raised.

There is no restriction on the number of parameters of this method.

## example

`FooToBarMapper` generated from `FooToBar` exposes the same method as `FooToBar`, including annotations on the return type and each parameter.

{% highlight java %}
@Mapper
public class FooToBar {
    @Nonnull
    public Bar map(@Nullable Foo foo) {
        // some code returning a Bar instance
        // initialized/populated from the specified Foo instance
    }
}
{% endhighlight %}

{% highlight java %}
@javax.annotation.Generated("fr.javatronic.damapping.processor.DAAnnotationProcessor")
public interface FooToBarMapper {
    @Nonnull
    Bar map(@Nullable Foo foo);
}
{% endhighlight %}

MapperImpl class
================

The second type generated by the DAMapping framework is the class that implements the *Mapper interface*.

The *dedicated class* could be implementing this interface, but it is illegal to modify source code when doing annotation processing and also we don't want the framework to alter the developer's code.

This class is the one supposed to be used in code. It delegates its implementation to a internal instance of the *dedicated class* (instanced in constructor).

## name and location

The name of the *MapperImpl class* is created by appending `MapperImpl` to the name of the *dedicated class*, e.g. the name of the *MapperImpl class* for the *dedicated class* `FooToBar` is `FooToBarMapperImpl`.

## annotations

The *MapperImpl class* is not generated with class annotation except for the `@Generated` annotation that indicates the type has been generated.

Also, when the *dedicated class* is annotated with `@Injectable`, any annotation annotated with `@javax.inject.Scope` on the *dedicated class* will be added to generated *MapperImpl class*.

>Note that `@Scope` support is currently experimental since it can not be fully used until annotations with `@javax.inject.Qualifier` are also supported

## constructor

If the *dedicated class* does not define any constructor or only a constructor without parameters, the *MapperImpl class* will have no explicit constructor.

Otherwise, the *dedicated class* must defined only one constructor, otherwise an exception will be raised.

The constructor of the *MapperImpl class* will have the same parameters, including annotations, as the *dedicated class* constructor.

## constructor annotations

The constructor of the *MapperImpl class* will have no annotation except the `@Inject` annotation if the *dedicated class* is annotated with `@Injectable`.

Using Mapper interfaces in dedicated class
==========================================

Using a generated *Mapper interface* in *dedicated class* is supported and actually highly encouraged as it is the basic pattern to implement mapping of trees of objects.

To use a *Mapper interface* in the object mapping code of a *dedicated class*, simply declare a (private and final) property and have it initialized in the constructor of the *dedicated class*.

{% highlight java %}
@Mapper
public class AcmeToViten {
    private final FooToBarMapper fooToBarMapper;

    public AcmeToViten(FooToBarMapper fooToBarMapper) {
        this.fooToBarMapper = fooToBarMapper;
    }

    public Viten map(Acme acme) {
        // [...]
        vilen.setBar(fooToBarMapper.map(acme.getFoo()));
        // [...]
        return vilen;
    }
}
{% endhighlight %}

DI frameworks support
=====================

The DAMapping framework provides some support to integrate generated classes and interfaces with a dependency injection framework.

This support is currently part of the core of the framework but it might get provided as an extension in the near future.

The general idea is that the developer has barely any extra thing to do to configure a *dedicated class* to generate a *MapperImpl* class to integrate with a DI framework that he or she would have to do to configure a class of its own:

1. add the `@Injectable` annotation to the *dedicated class*, this annotation enables DI framework support (that's the only extra step)
2. add any DI related annotation to the *dedicated class* or the constructor, they will be included on the generated *MapperImpl class* and its constructor

## JSR-330

The DAMapping framework offers a generic support for DI Framework through the JSR-330 annotations.

It is currently limited to generating class types that will declare having dependencies to be injected, exclusively using constructor injection for the moment.

These types can then be declared to the DI framework of the developer's choice.

## @Injectable

The `@Injectable` annotation provided by the framework can be added to a *dedicated class* to enable DI framework integration on it.

If the *dedicated class* declares a non-default constructor, the generated *MapperImpl class* will declare a constructor with the same parameters (as any Mapper class) but the constructor will additionally be annotated with `@javax.inject.Inject`.

Also, if the *dedicated class* has annotations annotated with `@javax.inject.Scope`, the generated *MapperImpl class* will also be annotated them.

## constructor injection

Currently, the DAMapping framework supports only constructor injection. 

Property or setter injection are not supported as it poses specific technical difficulties.

## Qualifier annotations

Annotations annotated with `@Qualifier` on parameters of the constructor of the *dedicated class* will be added to the parameters of the constructor of the generated *MapperImpl class*. This enables the use of qualified dependencies in dedicated classes.

`@Qualifier` annotations can not yet be added to the *MapperImpl class* itself. This feature is planned for 0.6.0 and will enable features such as Spring's package scan.

## Scope annotations

Annotations annotated with `@Scope` on the *dedicated class* will be added to the generated *MapperImpl class*.

## integration samples

You can check out the integration tests of the DAMapping framework to get examples of integration with:

* the [Spring framework](http://projects.spring.io/spring-framework/): [SpringHotelControllerTest](https://github.com/lesaint/damapping/blob/master/integration-test/use-mapper/src/test/java/fr/javatronic/damapping/test/injectable/SpringHotelControllerTest.java)
* the [Dagger 1 Framework](http://square.github.io/dagger/): [DaggerHotelControllerTest](https://github.com/lesaint/damapping/blob/master/integration-test/use-mapper/src/test/java/fr/javatronic/damapping/test/injectable/DaggerHotelControllerTest.java)

<!--

Mapper factory
==============

There might be times:
* when object mapping code should be configured from a data which can not be injected, which is not available when instantiating the mapper
* because it is only available at runtime for example
* when the mapper should be stateful (hum... code smell?) and therefor a new instance used each time it is used
* when two or more mappers are only slight variations of the same one

In all theses cases (and maybe some others) you need to use a factory which will return multiples implementations of a *Mapper interface* instead of a single one.

## how to create one

A Mapper factory is defined as a *dedicated class* with at least one method annotated with `@MapperFactory`.

The `@MapperFactory` annotation can be added to:

* either on all constructors of the dedicated class
* or static method(s) of the dedicated class

-->

# IDE integration

## IntelliJ IDEA

Since IntelliJ IDEA does not compile source files, it is not aware of types generated by the annotation processing integrated into the compiling process.

Therefor, unless the project is built and the generated source directory is added to the classpath, references to generated *Mapper interfaces* or generated *MapperImpl classes* will be displayed has errors.

To avoid building the project all the time and make the coding experience with the DAMapping framework more fluent, the developer should install the DAMapping plugin for IntelliJ (work in progress).

## Eclipse

Since the DAMapping framework does not yet support the Eclipse compiler, build in Eclipse will fail.

Support for the Eclipse compiler is planned for version 0.6.0.
