title: Create an Android app from scratch, with CI, and no knowledge - Part 3
tags: Android

[TOC]

!!! warning " This is a multi-part article"
    You're reading part 3.
    
    * [Part 1]({filename}/articles/2024-09-13_create_an_android_app_from_scratch_part_1.md) focuses on bootstrapping an Android app dev project and run it on an emulated device
    * [Part 2]({filename}/articles/2024-09-14_create_an_android_app_from_scratch_part_2.md) focuses on deploying the app to my phone and create a CI pipeline producing APKs
    * [Part 3]({filename}/articles/2024-10-11_create_an_android_app_from_scratch_part_3.md) focuses on basic Jetpack Compose and Kotlin programming to create a demo UI for LMS


So far, we worked on the Hello World Android App generated by Android Studio.

However, the point of all this is to create the TODO LINK MVP of an Android App for LMS, and find out how easy/hard it is.

The requirements are:

* an input field to search, initially empty
* a list displaying persons (id, first name, and last name)
* the same behaviors as the PyLMS UI: display all persons by default, display the result of filtering first and last name by the value of the input field on submit
* (Optional) use state-of-the-art/recommended UI patterns for Android


Kotlin for programming
======================

I knew from keeping an eye on the news that Kotlin is THE programing language for Android for a while.

I never programmed with Kotlin. I do have a high-level understanding of the language from looking at Java-Kotlin
comparison articles over time and collaborating with Kotlin developers at work. 

I'm happy to have a practical opportunity to learn a new language. Plus, I'm super eager to find out how a language
intended to provide a faster and more fluent syntax for coding on the JVM compares to Python.

Jetpack Compose for the UI
==========================

I recalled from past looks at Android programming that the UI was coded with XML. And indeed, the 1st few resources I
found confirmed it.

Yet, my deep self couldn't help but try and find an alternative where I could code everything (eg. generate XML with Code). 

And indeed, after a little googling, I stumbled upon articles talking about Jetpack Compose as the new and recommended
way of UI programming for Android, and I liked what I saw.

In a nutshell, Jetpack Compose has nothing to do with XML and my understanding of it is:

* it is based on Kotlin functions, annotated with `@Composable`, each describing a piece of the UI
* functions are composed of one another, down to using Jetpack Compose base UI `@Composable` functions (eg. an input field) (or drawing functions -- I guess), 
* and variables implementing `State` (or more commonly `MutableState`), to hold any state related to the UI.

Jetpack Compose is then responsible for drawing the UI calling these methods, as well as refreshing the UI, upon 
both user/system events and changes of state variables (which Jetpack monitors), calling **only the 
impacted** functions.

As a consequence, it's important to understand that `@Composable` functions:

* may **not** be called [in the order](https://developer.android.com/develop/ui/compose/mental-model#any-order) they are defined in code,
* will be called [multiple times](https://developer.android.com/develop/ui/compose/mental-model#frequent),
* can be called [in parallel](https://developer.android.com/develop/ui/compose/mental-model#parallel),
* as a consequence, they **must not have side effects**.

!!! note
    `@Composable` functions are expected to be named with a capital head letter. This is not standard for Kotlin.

    Since functions are typically named after components, my guess is that it is intended to make it easier for
    developers to reason around functions as composable UI components.

!!! hint " Sources"
    * [Why adopt Compose - Android Developer](https://developer.android.com/develop/ui/compose/why-adopt)
    * [Thinking in Compose - Android Developer](https://developer.android.com/develop/ui/compose/mental-model)


Recommended Android app UI
==========================

I'm not a UI guy. So, my go-to action is to find references on how to design an Android app.

Turns out, there is exactly that, provided directly by Google: [Material Design 3](https://m3.material.io/).

`Scaffold` is a top component, provided by Jetpack Compose, that provides scaffolding to create an App with the
typical (and recommended) appearance: a top bar, a bottom bar, content in the middle, and a floating action
button.

I took the code sample from Android Developer and built my MVP from there:

* ‚ûä usage of the `TopAppBar` function requires adding `OptIn(ExperimentalMaterial3Api::class)` to the wrapping `@Composable` function
* ‚ûã color code copy/pasted from code example
* ‚ûå top bar only need to contain the name of the App for now
* ‚ûç bottom bar will display infos about displayed data, whether it's filtered or not
* ‚ûé I disabled/hide the floating button as it is out of scope of the MVP, but it seems a great way to add a new person
* ‚ûè this function defines the "content" (what's between top and bottom bars) and takes a parameter `innerPadding` which 
     must be passed to the top inner component. If not passed, inner content will render behind the top bar (if top aligned).
* ‚ûê more on `PersonsList` below (see [List of persons](#list-of-persons))
* ‚ûë passing the padding value as a `Modifier` type to `PersonsList`

```kotlin
@OptIn(ExperimentalMaterial3Api::class) # ‚ûä
@Composable
fun AndroLMSScaffold() {
    Scaffold(topBar = {
        TopAppBar(colors = TopAppBarDefaults.topAppBarColors( # ‚ûã
            containerColor = MaterialTheme.colorScheme.primaryContainer,
            titleContentColor = MaterialTheme.colorScheme.primary
        ), title = {
            Text("AndroLMS") # ‚ûå
        })
    }, bottomBar = {
        BottomAppBar(
            containerColor = MaterialTheme.colorScheme.primaryContainer,
            contentColor = MaterialTheme.colorScheme.primary,
        ) {
            Text(
                modifier = Modifier.fillMaxWidth(),
                textAlign = TextAlign.Center,
                text = "Displaying everything",
            )
        }
//    }, floatingActionButton = { # ‚ûé
//        FloatingActionButton(onClick = { }) {
//            Icon(Icons.Default.Add, contentDescription = "Create person")
//        }
    }) { innerPadding -> # ‚ûè
        PersonsList( # ‚ûê
            modifier = Modifier.padding(innerPadding) # ‚ûë
        )
    }
}
```

!!! tip
    Compose appears to make extensive use of the Kotlin convention that allows writing a lambda expression
    after the function's arguments when the trailing parameter is a function (see ‚ûè).   
    I find this quite neat, and it does improve the readability of the code.  
    At first sight, though, it does create confusion of capitalized functions with call to class constructors.

!!! note
    Usage of `@OptIn(ExperimentalMaterial3Api::class)` may not be required in 35 and above, it is with API 34 (the one I target for my phone).

!!! hint " Sources"
    * [Get to know Material 3 - material.io](https://m3.material.io/get-started)
    * [Scaffold code example - Android Developer](https://developer.android.com/develop/ui/compose/components/scaffold#example)
    * [Passing trailing lambdas - Kotlinlang.org](https://kotlinlang.org/docs/lambdas.html#passing-trailing-lambdas)
    
List of persons
===============

To display a list of persons, I looked for a List, or tree component.

I didn't find one and quick googling (and asking Copilot on Skype - I had to use the software for communication, 
discover it had a bot built-in and gave it a try) taught me that the correct approach with Android is to use a `Column`
component with any other repeated component inside. A `Text` one will do.

* üÑå introducing a data class to mock a `Person` in the app
* ‚ûä following Compose approach, every piece of the UI is a `@Composable` function
* ‚ûã to be side-effect-free, it must take the list of persons to display as a parameter
* ‚ûå and accept the padding from `Scaffold` to not be displayed behind the top bar
* ‚ûç using `LazyColumn` instead of `Column` to get a vertical scrollbar
* ‚ûé using the `items` function from the `LazyDsl` to load all the persons at once (which is not lazy at all, but [KISS](https://en.wikipedia.org/wiki/KISS_principle))
* ‚ûè each person is represented on screen with a `PersonView`, another `@Composable` function
* ‚ûê a `PersonView` is only made of one `Text`, which content is the person's id followed by first and last name
* ‚ûë the `Text` takes the full width of the screen (and content is left-aligned by default -- is it localized?)

```kotlin
data class Person(val id: Int, val firstname: String, val lastname: String?) # üÑå

@Composable
fun PersonsList( # ‚ûä
    persons: List<Person>, # ‚ûã
    modifier: Modifier # ‚ûå
) {
    LazyColumn(modifier = modifier) { # ‚ûç
        items(persons) { # ‚ûé 
            item: Person -> PersonView(item) # ‚ûè
        }
    }
}

@Composable
fun PersonView(person: Person) { # ‚ûè
    val lastname = if (person.lastname != null) " " + person.lastname else ""
    Text( # ‚ûê
        text = "(${person.id}) ${person.firstname}${lastname}",
        modifier = Modifier.fillMaxWidth() # ‚ûë
    )
}
```

To provide a list of persons to `PersonsList`, the calling code must be changed a bit:

* ‚ûä create a mocked list of 300 persons, odd ones don't have a last name
* ‚ûã we will change the list of persons and let's take the good habit of passing any data to the UI as `State`.   
     This is not required though, passing `p` will equally work for static content as it is now.
* ‚ûå skipping unchanged constructor parameters in this snippet
* ‚ûç pass the persons

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AndroLMSScaffold() {
    val p = (1..300).map { Person(it, "fn${it}", if (it % 2 == 0) "ln${it}" else null) } # ‚ûä
    var persons by remember { mutableStateOf(p) } # ‚ûã

    Scaffold(
        [...] # ‚ûå
    ) { innerPadding ->
        PersonsList(
            persons = persons, # ‚ûç
            modifier = Modifier.padding(innerPadding)
        )
    }
}
```

The result looks quite plain, but data is displayed and scrolling works:

![Screenshot simplistic display of a list of persons]({static}/images/2024-10-11_create_an_android_app_from_scratch_part_3/simplistic_list_of_persons.png)

!!! hint " Sources"
    * [Scaffold component doc and code example - Android Developer](https://developer.android.com/develop/ui/compose/components/scaffold)
    * [Standard layouts, including Column - Android Developer](https://developer.android.com/develop/ui/compose/layouts/basics#standard-layouts)
    * [Lazy lists - Android Developer](https://developer.android.com/develop/ui/compose/lists#lazy)
    * [Lazy column documentation - Android Developer](https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1))

Improve PersonView
==================

The least improvement to make is to have a clearer separation of the people lines and plan for future touch actions on 
them, highlighting the sensitive zone of each line.

* ‚ûä the `Card` function adds a background with rounded corners out of the box 
* ‚ûã adds a little distance between cards
* ‚ûå just add previous `Text` as content for now. `Card` is a container and would make it easy to add an icon, multiple texts with diverse alignments, ...

```kotlin
@Composable
fun PersonView(person: Person) {
    Card(modifier = Modifier.padding(5.dp)) { # ‚ûä ‚ûã
        val lastname = if (person.lastname != null) " " + person.lastname else ""
        Text( # ‚ûå
            text = "(${person.id}) ${person.firstname}${lastname}",
            modifier = Modifier.fillMaxWidth()
        )
    }
}
```

![Screenshot display of a list of persons with Card]({static}/images/2024-10-11_create_an_android_app_from_scratch_part_3/PersonView_with_a_Card.png)

!!! hint " Sources"
    * [The Card base component - Android Developer](https://developer.android.com/develop/ui/compose/components/card)

Search field
============

### Add a TextField

To allow searching a person, I'll add an input field between the top bar and the list of persons.

* ‚ûä using a `Column` to put the search field "on top" of the list of persons, withing the content of the `Scaffold` 
     component. Note that the `Column` receives the modifier from `Scaffold` not the `LazyColumn` anymore.
* ‚ûã using a `Composable` function for the search field is overkill at this stage since it contains a single component
     but this will become useful as the component becomes more complex
* ‚ûå add a `10` "dp" (for Density Independent Pixel, aka. dpi) between the search field and the list
* ‚ûç Using an `OutlinedTextField`, only the style changes and I believe it looks much better at very low cost
* ‚ûé parameters `value` and `onValueChange` are discussed below (TODO link). They are mandatory, so provide empty values
* ‚ûè use "Search" as label. it is plain text but could easily include an icon or whatever. Out of the box, the label 
     neatly appears within the text field until the user focuses on it, and it moves to the top-left and over the outline. 
* ‚ûê limit the field to display only one line. At this stage, user can use return to create more than one line, and they
     won't be visible.

```kotlin
@Composable
fun PersonsList(persons: List<Person>, onSearchStringChange: (String) -> Unit, modifier: Modifier) {
    Column(modifier = modifier) {
        SearchField(onSearchStringChange) 
        LazyColumn(modifier = Modifier.padding(start = 0.dp, end = 0.dp, top = 10.dp, bottom = 0.dp)) {
            items(persons) { item: Person -> PersonView(item) }
        }
    }
}

@Composable
fun SearchField() { # ‚ûã
    OutlinedTextField( # ‚ûç 
        value = "", # ‚ûé
        onValueChange = {}, # ‚ûé
        label = { Text("Search") }, # ‚ûè
        modifier = Modifier.fillMaxWidth(),
        singleLine = true, # ‚ûê
    )
}
```

![Screenshot OutlinedTextField out of focus]({static}/images/2024-10-11_create_an_android_app_from_scratch_part_3/Plain_OutlinedTextField_out_of_focus.png)

![Screenshot OutlinedTextField in focus]({static}/images/2024-10-11_create_an_android_app_from_scratch_part_3/Plain_OutlinedTextField_in_focus.png)

!!! hint " Sources"
    * [Density independence and DP - Material Design](https://m2.material.io/design/layout/pixel-density.html#density-independence)
    * [Choose TextField implementation - Android Developer](https://developer.android.com/develop/ui/compose/text/user-input#choose-textfield)


### React upon line return

In its current form, the TextField displays only one line but accepts line returns to create more than one.

I'd rather have search triggered when the user hits enter/line return and use the content of the `TextField` to filter the list.
As a first step, I'll display the filtering string in the bottom bar.

This can be achieved with `TextField` built-in `keyboardOptions` :

* ‚ûä define a state `string` variable named `searchQuery` to hold the value of the search
* ‚ûã `topBar` is unchanged
* ‚ûå the `bottomBar` will display "Displaying everything" unless `searchQuery` has content. It will be automatically updated when `searchQuery` is updated
* ‚ûç pass a function to `PersonsList` (see below) that takes some text and set it as value of `searchQuery` 
* ‚ûé `PersonsList` now accepts a function and pass it as is to `SearchField`
* ‚ûè `SearchField` now accepts a function argument. This function takes a single `string` argument and returning nothing
* ‚ûê define a state `string` variable named `localText` to hold the content of the textfield. Using parameter `onValueChange` and a lambda, this variable is updated with every change of the `TextField` content.
* ‚ûë when `imeAction` is `ImeAction.Search`, an amplifying glass is displayed on the keyboard. No new line can be added to the `TextField`, instead a keyboard action called 'search' is triggered.
* ‚ûí define a `keyboardActions` when 'search' is triggered, function `onSearchStringChange` is called with the current value of `localText`.

```kotlin
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AndroLMSScaffold() {
    val p = (1..300).map { Person(it, "fn${it}", if (it % 2 == 0) "ln${it}" else null) }
    var searchQuery by remember { mutableStateOf("") } # ‚ûä
    var persons by remember { mutableStateOf(p) }
    
    Scaffold(topBar = {
        [...] # ‚ûã
    }, bottomBar = {
        BottomAppBar(
            containerColor = MaterialTheme.colorScheme.primaryContainer,
            contentColor = MaterialTheme.colorScheme.primary,
        ) {
            Text(
                modifier = Modifier.fillMaxWidth(),
                textAlign = TextAlign.Center,
                text = if (searchQuery.isNotEmpty()) "Searching for ${searchQuery}..." else "Displaying everything", # ‚ûå
            )
        }
    }) { innerPadding ->
        PersonsList(
            persons = persons,
            onSearchStringChange = { text: String -> # ‚ûç
                searchQuery = text
            },
            modifier = Modifier.padding(innerPadding)
        )
    }
}

@Composable
fun PersonsList(persons: List<Person>,
                onSearchStringChange: (String) -> Unit, # ‚ûé
                modifier: Modifier) {
    Column(modifier = modifier) {
        SearchField(onSearchStringChange) # ‚ûé
        LazyColumn(modifier = Modifier.padding(start = 0.dp, end = 0.dp, top = 10.dp, bottom = 0.dp)) {
            items(persons) { item: Person -> PersonView(item) }
        }
    }
}

@Composable
fun SearchField(onSearchStringChange: (String) -> Unit) { # ‚ûè
    var localText by remember { mutableStateOf("") } # ‚ûê

    OutlinedTextField(
        value = localText, # ‚ûê
        onValueChange = { localText = it }, # ‚ûê
        label = { Text("Search") },
        modifier = Modifier.fillMaxWidth(),
        singleLine = true,
        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search), # ‚ûë
        keyboardActions = KeyboardActions(onSearch = { # ‚ûí
            onSearchStringChange(localText)
        }),
    )
}
```

![Screenshot Amplifying glass on the keyboard]({static}/images/2024-10-11_create_an_android_app_from_scratch_part_3/amplifying_glass_on_the_keyboard.png)

![Screenshot Search string in bottom bar]({static}/images/2024-10-11_create_an_android_app_from_scratch_part_3/search_string_in_bottom_bar.png)

!!! hint " Sources"
    * In a question on how to hide the keyboard (see [below](#hide-keyboard-upon-line-return)), a user demonstrates [how to use `ImeAction.search` - Stackoverflow](https://stackoverflow.com/q/69124822)
    * [Best practices with TextField state - Android Developer](https://developer.android.com/develop/ui/compose/text/user-input#state-practices)
    * [Effective State Management for TextFields - Medium](https://medium.com/androiddevelopers/effective-state-management-for-textfield-in-compose-d6e5b070fbe5)

### Hide keyboard upon line return

The keyboard taking a big share of the screen, I was immediately frustrated not seing the whole list once I hit search.

To hide the keyboard upon hitting search:

* ‚ûä trigger the ImeAction `Done` to hide the keyboard and presumably release focus. `TextField` keeps it in this case, though. I assume because no other component can take it.

```kotlin
@Composable
fun SearchField(onSearchStringChange: (String) -> Unit) {
    var localText by remember { mutableStateOf("") }

    OutlinedTextField(
        value = localText,
        onValueChange = { localText = it },
        label = { Text("Search") },
        modifier = Modifier.fillMaxWidth(),
        singleLine = true,
        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),
        keyboardActions = KeyboardActions(onSearch = {
            onSearchStringChange(localText)
            this.defaultKeyboardAction(ImeAction.Done) # ‚ûä
        }),
    )
}
```

Behavior upon triggering the keyboard action is not specifically defined, and could be platform dependant/change over time.

An alternative is to use `LocalSoftwareKeyboardController`, which is specific to the behavior we are looking for, and will
come in handy when we can't access the `KeyboardActionScope` (the type exposing function `defaultKeyboardAction`):

* ‚ûä get the current `LocalSoftwareKeyboardController`
* ‚ûã call the `hide` function. Usage of `?.` operator appears to be required. 

```kotlin
@Composable
fun SearchField(onSearchStringChange: (String) -> Unit) {
    var localText by remember { mutableStateOf("") }
    val keyboardController = LocalSoftwareKeyboardController.current # ‚ûä

    OutlinedTextField(
        value = localText,
        onValueChange = { localText = it },
        label = { Text("Search") },
        modifier = Modifier.fillMaxWidth(),
        singleLine = true,
        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),
        keyboardActions = KeyboardActions(onSearch = {
            onSearchStringChange(localText)
            keyboardController?.hide() # ‚ûã
        }),
    )
}
```

!!! hint " Sources"
    * [Hide the keyboard with ImeAction.Done after hitting search - Stackoverflow](https://stackoverflow.com/a/76600586)
    * [Use LocalSoftwareKeyboardController to hide the current software keyboard - Stackoverflow](https://stackoverflow.com/a/63696027)
    * [IMEAction - API reference](https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction)


### Add icon to clear search

Out of curiosity rather than out of necessity, I wanted to find out how I could implement a clear button on the search field.

`TextField` defines a trailing icon out of the box. It's only a matter of adding some behavior to it and find a way to 
display it only when the TextField is not empty:

* ‚ûä other parameters unchanged
* ‚ûã `if` could be used and be a little shorter, but I like how using `when` makes the code more descriptive
* ‚ûå use `localText.isNotEmpty()` to display the icon only when the TextField has some content
* ‚ûç use system's icon for 'Clear'
* ‚ûé hide the keyboard
* ‚ûè clear the `TextField`
* ‚ûê update the bottom bar

```kotlin
@Composable
fun SearchField(onSearchStringChange: (String) -> Unit) {
    var localText by remember { mutableStateOf("") }
    val keyboardController = LocalSoftwareKeyboardController.current

    OutlinedTextField(
        [...], # ‚ûä
        trailingIcon = {
            when { # ‚ûã
                localText.isNotEmpty() -> Icon(  # ‚ûå
                    Icons.Default.Clear, # ‚ûç
                    contentDescription = "clear search",
                    modifier = Modifier.clickable {
                        keyboardController?.hide() # ‚ûé
                        localText = "" # ‚ûè
                        onSearchStringChange("") # ‚ûê
                    }
                )
            }
        }
    )
}
```

![Screenshot Clear TextField button]({static}/images/2024-10-11_create_an_android_app_from_scratch_part_3/clear_textfield_button.png)

!!! hint " Sources"
    * [Trailing icon to clear TextField - Stackoverflow](https://stackoverflow.com/a/68483797)
    * [Display Trailing icon only when TextField is not empty - Stackoverflow](https://stackoverflow.com/a/71887430)


Filter the list of persons
==========================

Finally, it's time to filter the content of the list:

* ‚ûä move variable `p` with dummy content to a function implementing filtering with (really) dummy code
* ‚ûã assign variable `person` with list of persons filtered by with an empty search string
* ‚ûå when search string is modified, assign variable `person` with the filtered list of persons

```kotlin

private fun searchPersons(text: String): List<Person> { # ‚ûä
    val p = (1..300).map { Person(it, "fn${it}", if (it % 2 == 0) "ln${it}" else null) }
    return p.filter { it.firstname.contains(text) }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AndroLMSScaffold() {
    var persons by remember { mutableStateOf(searchPersons("")) } # ‚ûã 
    var searchQuery by remember { mutableStateOf("") }

    Scaffold(
        [...]
    }) { innerPadding ->
        PersonsList(
            persons = persons,
            onSearchStringChange = { text: String ->
                searchQuery = text
                persons = searchPersons(text) # ‚ûå
            },
            modifier = Modifier.padding(innerPadding)
        )
    }
}
```
