---
layout: post
title: "Processing types with reference to code generated by an Annotation Processor"
tags: [AnnotationProcessor]
image:
 feature: feature_image_green.png
---

When any piece of code has reference(s) to type(s) generated by an Annotation Processor, such code can not compile until the Annotation Processor runs and generates these referenced type(s).

The Java compiler deals with that by trying and recompiling every piece of code which is not yet compiled after each round of annotation processing.

What is not dealt with by the Java compiler though, is when the reference to generated code is **inside** the code that the Annotation Processor will process. In which case, what the Annotation Processor sees is a class with a compilation error (an unresolved reference, to be more specific).

The problem is: there is no way to make a difference between an unresolved reference to a generated type and an unresolved reference to a type that just does not exist (or does not compile, whatever the reason).

After a detailed example to make the specific problem clearer and a general description of the Annotation processing process, this article will detail the compilation steps in such case and present how this has been solved in [DAMapping](https://github.com/lesaint/damapping).


## description by example

Let's take the example of ```DAmapping``` Annotation Processor which must not generate any code from a type which does not compile.

Let's pretend that we have three classes (class ```Foo```, class ```Bar``` and class ```Acme```) which are processed by DAMapping Annotation Processor to generate types which name is the name of the source class suffixed with "Mapper": respectively, ```FooMapper```, ```BarMapper``` and ```AcmeMapper```.

[insert here image of the three classes and the three generated classes]

Now, lets say that class ```Foo``` references ```BarMapper``` and class ```Acme``` references some non-existing type ```Miraculous``` (as a constructor parameter for example). 

```java
@Mapper
public Foo {
    private final BarMapper barMapper;
    public Foo(BarMapper barMapper) {
        this.barMapper = barMapper;
    }
    [...]
}
```

> class ```Foo``` has a private property, set by constructor, of type ```BarMapper```.
> You can imagine class ```Acme``` is just the same, but with the type ```Miraculous```

What is expected from ```DAMapping``` Annotation Processor is to generate ```FooMapper``` but not ```AcmeMapper```. The former's soure class will compile once  ```Bar``` has been processed but ```Acme``` will never compile because ```Miraculous``` does not exist.

The problems are the following: 

1. there is no garanty we will process ```Bar``` before ```Foo```
2. even though it would be the case, both class will be part of the same round (see below) and ```Foo``` will still have an unresolved reference to ```BarMapper``` even though we just generated it
3. from inside the Annotation Processor code, there is really no difference between the unresolved reference to ```BarMapper``` and the one to ```Miraculous```. Both references are described as a ```TypeMirror``` passed by the compiler with a ```kind``` property which value is ```TypeKind.ERROR```.

## what happens when compiling

### the general idea

As long as it finds at least one source file with at least one annotation and as long as it is aware of at least one Annotation Processor, the compiler will create a first round of annotation processing.

Every processing round is made of:

* a list of input files
* which all have at least one of the annotations in the list of annotations of the round
* and a list of annotation processor(s) which will be passed that lot of information (all of which have registered to at least one of the annotations in the list above).

The compiler will create any number of round until is reaches the final round made of no input files.

Input files could be defined as source files with at least one [Element](http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/Element.html) (a package, a class/interface/enum or a method) and which hasn't yet been part of a round.

See [the javadoc of Processor](http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html) for full description of the annotation processing contract between the compiler and the ```Processor``` implementations.

My understanding is that the compiler is contractualy free to build rounds as any combination of the three lists above but with the respect of this rule: an input file is processed only once, it will be part of one and only one round.

But experimentaly (*), I found that all source files with at least one annotation and all annotation processor with at least one of their registered annotations used in at least one source file, are all processed in the first round.

As a result, subsequent rounds (not counting the last one which is always there) will be created only if at least one new source file with an annotation has generated by the previous round.

> (*) projects used to make thoses experiments are available online and described in the [README.md](https://github.com/lesaint/annotation-processing-explained#experimentations-on-annotation-processing)

### writing an Annotation Processor

#### the ```Processor``` interface

TODO: explain the methods of the interface here

#### the ```AbstractProcessor``` abstract class

TODO: explain how it works, give an example, tell why we dont use it in DAMapping

#### the discovery process

To avoid declaring manually the annotation processor, one can create a file ```META-INF/service/javax.annotation.processing.Processor``` which contains one line for each ```Processor``` implementation.

The Compiler will automatically scan for this file in the class path when beeing run and use it to instanciate Annotation Processors.

#### compiling the Annotation Processor

TODO: Javac Annotation Processing must be explicitly disabled

#### life-cycle of a ```Processor``` instance


### example for our specific case

Assuming that we are compiling a project that contains only the classes described above, here is how compilation and annotation processing will occur (assuming also that ```DAMapping``` Annotation Processor has been discovered, ie. project is correctly configured).

#### first round

During the first round, the compiler will create an annotation processing round with all classes of the project (since they are all annotated with ```@Mapper``` and there are so few, a single round is enough).

Since they are annotated with ```@Mapper``` (the annotation registered by DAMapping Annotation Processor), ```DAMapping``` Annotation Processor will be part of this round.

```
Round 1:
    input files: {fr.javatronic.blog.Acme, fr.javatronic.blog.Foo, fr.javatronic.blog.Bar}
    annotations: [fr.javatronic.damapping.annotation.Mapper]
    last round: false
Processor fr.javatronic.damapping.processor.DAAnnotationProcessor matches [fr.javatronic.damapping.annotation.Mapper] and returns true.
```

DAMapping Annotation Processor will be able to retrieve all type annotated with @Mapper in that round and will generate classes from any of them found valid (such as valid use of annotation, existing mapper method, ...) and which types will all resolve (ie. no variable, property, import, ... references an unkown type).

Unfortunatly, in the case of class ```Foo```, since it has a reference to a generated class (```BarGenerated```) there is at least one unresolved type and DAMapping can not generate ```FooMapper```.

#### second round

Since ```DAMapping``` Annotation Processor generated some classes and interfaces (```BarMapper```) with at least one annotation (here ```@Override```), a second round is created by the compiler.

```
Round 2:
    input files: {fr.javatronic.blog.BarMapper, fr.javatronic.blog.BarMapperImpl}
    annotations: [java.lang.Override]
    last round: false
Processor fr.javatronic.damapping.processor.DAAnnotationProcessor matches [] and returns true.
```

> Notice that neither ```AcmeMapper``` nor ```FooMapper```are in the input files list. The reason is because they do not exists.
> Also, for the sake of simplicity, we only took the generated interface which name ends with ```Mapper``` into account, but, as you may have notice, ```DAMapping``` actually generated two types from class ```Bar```

Note that at this point the ```Foo``` class compiles, since ```BarMapper``` has been generated.

But, unfortunalty for us, as far as the compiler is concerned, ```Foo``` has already been processed and it will never be part of another round.

#### last round

When there is no type in source code to process and if the previous round has generated no type at all, one last round will be created, with empty lists of input files and annotations.

This round could be seen as an opportunity for Annotation Processors to do some clean up or final source code generation.

By the way, any code generated during the last round will never be processed by the compiler, it is not called the last round for nothing.





### general notes about compiling and annotation processing

#### 

If there is no class in the source annotated with the annotation registered with by the Processor implementation, this implementation will never be instanced and will never take part with any round.

If there is no annotation processor matching any of the annotation on the types to compile there is zero round.

Once an annotation processor has taken part in a round, it will take part in all the subsequent rounds. **TODO verify this statement**

#### extra rounds

Extra rounds would not occure in the specific example describe above. But it is worth saying that if any type has been generated (by any Annotation Processor) or if there is type left from source code to process, there will be any number of extra round during which DAMapping annotation processor will be called, even if none is annotated with ```@Mapper```.

Formelly, as per this definition, the second round is an extra round.





TODO :
 - activer les logs annotation processing sur un gros projet pour voir s'il limite le nombre de type par round
     + vérifier si DAMapping annotation processor est instantié dès le 1er round ou dés le round où apparait au moins une classe annotée avec @Mapper (ie. une des annotations enregistrée par le mapper)
 - vérifier que dans tous les cas, un annotatio processor est bien appelé à tous les rounds, inclu le dernier

