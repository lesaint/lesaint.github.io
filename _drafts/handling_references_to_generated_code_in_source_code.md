---
layout: post
title: "Processing types with reference to code generated by an Annotation Processor"
tags:
 - Annotation Processing
 - Java
 - Compiler
categories: articles
image:
 feature: feature_image_green.png
---

This articles describes how to do write an Annotation Processor which handles types with references to class or interfaces which does not exist in source code but will be generated by the Annotation Processing.

## General description of the issue

When any piece of code has reference(s) to type(s) generated by an Annotation Processor, such code can not compile until the Annotation Processor runs and generates these referenced type(s).

The Java compiler deals with that by trying and recompiling every piece of code which is not yet compiled after each round of annotation processing.

What is not dealt with by the Java compiler though, is when the reference to generated code is **inside** the code that the Annotation Processor will process. In which case, what the Annotation Processor sees is a class with a compilation error (an unresolved reference, to be more specific).

The problem is: there is no way to make a difference between an unresolved reference to a generated type and an unresolved reference to a type that just does not exist (or does not compile, whatever the reason).

After a detailed example to make the specific problem clearer and a general description of the Annotation processing process, this article will detail the compilation steps in such case and present how this has been solved in [DAMapping](https://github.com/lesaint/damapping).

## Description by example

Let's take the example of ```DAmapping``` Annotation Processor which must not generate any code from a type which does not compile. This comes from the requirement to not generate code that does not compile.

Let's pretend that we have three classes (class ```Foo```, class ```Bar``` and class ```Acme```) which are processed by DAMapping Annotation Processor to generate types which name is the name of the source class suffixed with "Mapper": respectively, ```FooMapper```, ```BarMapper``` and ```AcmeMapper```.

[insert here image of the three classes and the three generated classes]

Now, lets say that class ```Foo``` references ```BarMapper``` and class ```Acme``` references some non-existing type ```Miraculous``` (as a constructor parameter for example). 

{% highlight java %}
@Mapper
public Foo {
    private final BarMapper barMapper;
    public Foo(BarMapper barMapper) {
        this.barMapper = barMapper;
    }
    [...]
}
{% endhighlight %}

> class ```Foo``` has a private property, set by constructor, of type ```BarMapper```.
> You can imagine class ```Acme``` is just the same, but with the type ```Miraculous```

What is expected from ```DAMapping``` Annotation Processor is to generate ```FooMapper``` but not ```AcmeMapper```. The former's soure class will compile once  ```Bar``` has been processed but ```Acme``` will never compile because ```Miraculous``` does not exist.

The problems are the following: 

1. there is no garanty we will process ```Bar``` before ```Foo```
2. even though it would be the case, both class will be part of the same round (see below) and ```Foo``` will still have an unresolved reference to ```BarMapper```. The object representation of ```Foo``` is built before the round and is not updated according to new classes/interfaces generated during the current round.
3. from inside the Annotation Processor code, there is really no difference between the unresolved reference to ```BarMapper``` and the one to ```Miraculous```. Both references are described as a ```TypeMirror``` passed by the compiler with a ```kind``` property which value is ```TypeKind.ERROR```.

### example for our specific case

Assuming that we are compiling a project that contains only the classes described above, here is how compilation and annotation processing will occur (assuming also that ```DAMapping``` Annotation Processor has been discovered, ie. project is correctly configured).

#### first round

During the first round, the compiler will create an annotation processing round with all classes of the project (since they are all annotated with ```@Mapper``` and there are so few, a single round is enough).

Since they are annotated with ```@Mapper``` (the annotation registered by DAMapping Annotation Processor), ```DAMapping``` Annotation Processor will be part of this round.

{% highlight sh %}
Round 1:
    input files: {fr.javatronic.blog.Acme, fr.javatronic.blog.Foo, fr.javatronic.blog.Bar}
    annotations: [fr.javatronic.damapping.annotation.Mapper]
    last round: false
Processor fr.javatronic.damapping.processor.DAAnnotationProcessor matches [fr.javatronic.damapping.annotation.Mapper] and returns true.
{% endhighlight %}

DAMapping Annotation Processor will be able to retrieve all type annotated with @Mapper in that round and will generate classes from any of them found valid (such as valid use of annotation, existing mapper method, ...) and which types will all resolve (ie. no variable, property, import, ... references an unkown type).

Unfortunatly, in the case of class ```Foo```, since it has a reference to a generated class (```BarGenerated```) there is at least one unresolved type and DAMapping can not generate ```FooMapper```.

#### second round

Since ```DAMapping``` Annotation Processor generated some classes and interfaces (```BarMapper```) with at least one annotation (here ```@Override```), a second round is created by the compiler.

{% highlight java %}
Round 2:
    input files: {fr.javatronic.blog.BarMapper, fr.javatronic.blog.BarMapperImpl}
    annotations: [java.lang.Override]
    last round: false
Processor fr.javatronic.damapping.processor.DAAnnotationProcessor matches [] and returns true.
{% endhighlight %}

> Notice that neither ```AcmeMapper``` nor ```FooMapper```are in the input files list. The reason is because they do not exists.
> Also, for the sake of simplicity, we only took the generated interface which name ends with ```Mapper``` into account, but, as you may have notice, ```DAMapping``` actually generated two types from class ```Bar```

Note that at this point the ```Foo``` class compiles, since ```BarMapper``` has been generated.

But, unfortunalty for us, as far as the compiler is concerned, ```Foo``` has already been processed and it will never be part of another round.



### general notes about compiling and annotation processing

#### 

If there is no class in the source annotated with the annotation registered with by the Processor implementation, this implementation will never be instanced and will never take part with any round.

If there is no annotation processor matching any of the annotation on the types to compile there is zero round.

Once an annotation processor has taken part in a round, it will take part in all the subsequent rounds. **TODO verify this statement**

#### extra rounds

Extra rounds would not occure in the specific example describe above. But it is worth saying that if any type has been generated (by any Annotation Processor) or if there is type left from source code to process, there will be any number of extra round during which DAMapping annotation processor will be called, even if none is annotated with ```@Mapper```.

Formelly, as per this definition, the second round is an extra round.





TODO :
 - activer les logs annotation processing sur un gros projet pour voir s'il limite le nombre de type par round
     + vérifier si DAMapping annotation processor est instantié dès le 1er round ou dés le round où apparait au moins une classe annotée avec @Mapper (ie. une des annotations enregistrée par le mapper)
 - vérifier que dans tous les cas, un annotatio processor est bien appelé à tous les rounds, inclu le dernier

