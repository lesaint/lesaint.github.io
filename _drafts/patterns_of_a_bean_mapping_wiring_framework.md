---
layout: post
title: Patterns of a Bean Mapping Wiring Framework
tags: Java BeanMapping
---

I talked in an previous [article]() of the need of doing Bean Mapping in Java a new way and how that involves designing and developing a Bean Mapping Wiring Framework.

In this article, I will try and go deeper into the design of such framework:

* goal and scope
* hypothesis of design
* technical patterns
* ...


# Goal and scope of a Bean Mapping Wiring Framework

The primary goal of a Bean Mapping Wiring Framework is to make easier/more fluent/less repetitive the use of Bean Mapping code whereever it is needed.

I identified two major use cases of Bean Mapping code integration:

1. Bean Mapping code is called from the application code
    * this may happen in any part of the application
2. Bean Mapping code is called from another piece of Bean Mappping code
    * this happens when one need to map the property of a bean which is itself a bean (aka mapping tree of beans)

## DI/IOC frameworks integration

Remember, the Bean Mapping Wiring Framework does not do Bean Mapping by itself.

In fact, it doesn't even do actual wiring (what?!).

What it does is either give every options to the developer to do the wiring by hand, her way, or integrate with the wiring framework the application already uses. The application's wiring framwork could be Spring, Guice, Dagger, [[TODO find name of Java's specification for Dependency Injection and IOC]], ... or any other Dependency Injection (`DI`)and/or Inversion Of Control (`IOC`) framework.

This integration could take the form of annotations added to the generated classes and/or generated configuration files (XML or other) and/or generated configuration classes, etc...

In the end, this integration will be a big part of the framework and the goal is to create a pluggable architecture for other framework integration (I'm thinking about a solution as simple as adding a jar to the classpath).

## Bean Mapping specific patterns

The scope of the Bean Mapping Wiring Framework also includes technical solutions to problems specific to Bean Mapping problems such as:

* mapping tree of beans
* mapping multiple source beans to a single bean
* mapping immutable bean (in fact, the framework should push for user to use immutable beans, we will talk about that in details later)
* mapping beans back and force
* mapping collection of beans
* ...

We will go over these solutions later in this article or in future articles.

# Hypothesis of design

We will now discuss the fondamental technical choices behind DAMapping, an initial implementation of a Bean Mapping Wiring Framework.

## everything will be compiled

I think the number one tool of the Java developer is the compiler. This is the strongest process giving garanties of a working program.

So, this new framework must make use of the compiler and must be typesafe.

Obviously, this statement ends wherever the typesafety ends when integrating with other tools.

## developer writes barely more than Bean Mapping code

The fondamental principal behind this new Bean Mapping paradigm is that the developer writes the Bean Mapping code.

But we should ask from the developer to do barely more than that.

Our goal is that the developer writes Bean Mapping code in a class and uses an annotation to tell the framework where that Bean Mapping Code is, in particular which method to call to execute that Bean Mapping code.

And that should be it.

## but we need interfaces

Obviously, we can't wire the developer's concret classes directly into the rest of the application or other Bean Mapping classes. We need interfaces:

* to enforce loose coupling
    - between the application and the Bean Mapping code
    - between multiple pieces of Bean Mapping code
* and promote unit testing as each piece of Bean Mapping code will be mockable
* which, combined with the power of the framework, will favor Separation Of Concern
    - there will be a lot less pain into multiplying smaller classes
* and overall Bean Mapping code will be very well tested and exactly as the developer wants it

Since it is not an option to make the developer's concret class implement this interface (technically borderline and too much intrusive), we will need a concrete class implementing it acting as a proxy (or facade) to the developer's class.

## so we will generate them using an Annotation Processor

Since Java 7 (and latest Java 6 versions), annotation processing is fully part of the compiler (annotation processing used to be implemented through a separate tool : APT).

`AnnotationProcessor` is the type which can be subclassed to perform annotation processing and which will be instanced and call directly by the compiler.

The compiler fully supports classes and interfaces generated by the Annotation Processors. Generated classes and interfaces are also compiled and can declare annotations which are in turn processed if necessary, generating classes if they need to, which are then compiled, and so on...

We will use annotation processing to generate the interfaces (and their implementations) the developer would have otherwise written to integrate its Bean Mapping code as cleanly as possible.

# Wiring pattern

## Core wiring pattern

Lets first start with the basic principle that the developer writes a concrete class of Bean Mapping code that exposes one non private method. Calling this method will "tranform" an instance of type `Foo` to an instance of type `Bar`.

The core pattern that implements from the points made in the previous chapter is the following:

![Core Pattern](/resources/java_bean_mapping_is_wrong_lets_fix_it/core_pattern.png)

> class `FooToBar` is written in the application code by the developer. This class exposes one method called `apply` which will implement the mapping from an instanceo of type `Foo` to a new instance of type `Bar`
> 
> The Bean Mapping Wiring Framework will generate the interface `FooToBarMapper` which exposes a method `apply` with exact same signature as the one in class `FooToBar`.
> 
> The framework will also generate a class `FooToBarMapperImpl` which implements `FooToBar` and is associated with an instance of type `FooToBar` to delegate the implementation of method `apply` inherited from the interface `FooToBar` 

As we will see in the rest of this article, this pattern will endure several variations to deal with various usecases but is really the [traduire: socle] of the Bean Mapping Wiring Framework.

## The challenge of associating the developer's class

Since we have control over all generated content, the only challenge in the pattern above is the association of an instance of the developer's class into our `FooToBarMapperImpl` instance.

Since we do not want to impose any specific way of writing her class to the developer, we need to support the different ways she could write it.

### class with default constructor

This kind of class can simply be instanced with the `new` operator. Association is actually a composition.

```java
class FooToBarMapperImpl implements FooToBarMapper {
    private final FooToBar instance = new FooToBar();

    public static Bar apply(Foo foo) {
        return instance.apply(foo);
    }

}
```

### class without a default constructor

This class can not be instanced with the `new` operator without some extra information from the developer about which value(s) to pass as argument(s) to the constructor.

Since we want to have the least possible configuration, it is not an option to ask the developer for this information. 

In addition, finding a way of describing how to instance such class would be a complexe challenge.

Since other tools are already dealing with that specific problem, DI frameworks. Also, as we are planning on integrating with DI frameworks, it would be stupid to try and reinvent the wheel. We'll see more on that later.

Also, a class with a non default constructor could be a `MapperFactory`.

### class with multiple constructors

Same problem as above (we do not know how to use the `new` operator) and same solution.

### Singleton enum

Singleton enum are very easy to compose in the `MapperImpl` class since we can have static reference to the class.

We know the qualified name of the developer's class and finding out the name of the single enum value is easy.

### Other type of singleton

### DI Framework integration

Several type of classes above can not be composed directly without extra information from the developer.

However. if the application is using a DI framework, the composition issue can be solved very easily by having the generated `MapperImpl` class injected with an instance.

## MappingImpl integration with the application
